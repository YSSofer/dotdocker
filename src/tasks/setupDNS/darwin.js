import Listr from 'listr';
import execa from 'execa';
import { resolve as resolvePath } from 'path';
import {
  access,
  writeFile as writeFileCallback,
  readFile as readFileCallback,
  mkdir as mkdirCallback,
} from 'fs';
import { promisify } from 'util';

const writeFile = promisify(writeFileCallback);
const readFile = promisify(readFileCallback);
const mkdir = promisify(mkdirCallback);
const resolverDirPath = '/etc/resolver/';
const resolverPath = resolvePath(resolverDirPath, 'docker');
const resolverContents = `# Generated by dotdocker
nameserver 127.0.0.1
port 533
`;

const fileExists = path => new Promise(resolve => access(path, null, err => resolve(!err)));

export default {
  title: 'Setting up DNS',
  task: () =>
    new Listr([
      {
        title: 'Creating resolver configuration directory',
        task: async () => {
          try {
            await mkdir(resolverDirPath);
          } catch (err) {
            if (err.code === 'EACCES')
              throw new Error(
                'This task needs elevated permissions. Please run again using sudo. This only needs to be done once.',
              );
            throw err;
          }
        },
        skip: () => fileExists(resolverDirPath),
      },
      {
        title: 'Creating resolver configuration file',
        task: async () => {
          try {
            await writeFile(resolverPath, resolverContents);
          } catch (err) {
            if (err.code === 'EACCES')
              throw new Error(
                'This task needs elevated permissions. Please run again using sudo. This only needs to be done once.',
              );
            throw err;
          }
        },
      },
      {
        title: 'Sending reload signal to mDNSResponder',
        task: () => execa('killall', ['-HUP', 'mDNSResponder']),
      },
    ]),
  skip: async () => {
    try {
      const fileContents = await readFile(resolverPath, 'utf8');
      if (fileContents === resolverContents) return 'Resolver is already configured';
      return false;
    } catch (err) {
      return false;
    }
  },
};
